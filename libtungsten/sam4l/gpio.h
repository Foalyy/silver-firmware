#ifndef _GPIO_H_
#define _GPIO_H_

#include <stdint.h>
#include "error.h"

// General Purpose Input Output
// This module controls the chip input/output signal pins
namespace GPIO {

    // Peripheral memory space base address
    const uint32_t GPIO_BASE = 0x400E1000;
    const uint32_t PORT_REG_SIZE = 0x0200;

    // GPIO base type
    typedef struct {
        volatile uint32_t RW;
        volatile uint32_t SET;
        volatile uint32_t CLEAR;
        volatile uint32_t TOGGLE;
    } RSCT_REG;

    // Registers addresses
    const uint32_t OFFSET_GPER =      0x000;
    const uint32_t OFFSET_PMR0 =      0x010;
    const uint32_t OFFSET_PMR1 =      0x020;
    const uint32_t OFFSET_PMR2 =      0x030;
    const uint32_t OFFSET_ODER =      0x040;
    const uint32_t OFFSET_OVR =       0x050;
    const uint32_t OFFSET_PVR =       0x060;
    const uint32_t OFFSET_PUER =      0x070;
    const uint32_t OFFSET_PDER =      0x080;
    const uint32_t OFFSET_IER =       0x090;
    const uint32_t OFFSET_IMR0 =      0x0A0;
    const uint32_t OFFSET_IMR1 =      0x0B0;
    const uint32_t OFFSET_GFER =      0x0C0;
    const uint32_t OFFSET_IFR =       0x0D0;
    const uint32_t OFFSET_ODCR0 =     0x100;
    const uint32_t OFFSET_ODCR1 =     0x110;
    const uint32_t OFFSET_OSRR0 =     0x130;
    const uint32_t OFFSET_STER =      0x160;
    const uint32_t OFFSET_EVER =      0x180;
    const uint32_t OFFSET_PARAMETER = 0x1F8;
    const uint32_t OFFSET_VERSION =   0x1FC;

    // Pins are divided in 3 ports : A, B and C
    // 48-pin packages only have port A, 64-pin packages have ports A and B,
    // and 100-pin packages have all A, B and C ports 
    const int N_PORTS = 3;
    enum class Port {A, B, C};

    // Each pin can either be controlled as a generic input/output (GPIO mode)
    // are be dedicated to one of up to 8 peripheral functions
    // See datasheet 3.2 Peripheral Multiplexing on I/O Lines for more details
    enum class Periph {A, B, C, D, E, F, G, H};    

    // Each pin has an optional pulling resistor, either pull-up or pull-down.
    // Buskeeper is a special mode where the pin keeps the last signal (high or low)
    // applied to it, even when this signal is disconnected.
    enum class Pulling {
        NONE,
        PULLUP,
        PULLDOWN,
        BUSKEEPER
    };
    
    // An interrupt can be generated by each pin on one of these signal change
    enum class Trigger {
        CHANGE,
        RISING,
        FALLING
    };


    // This is the main struct used to define a pin, this should be used in user space, e.g.
    // GPIO::Pin pinLed = {GPIO::Port::A, 2};
    // (function is unused for pins in basic GPIO mode and can be ommited)
    struct Pin {
        Port port;
        uint8_t number;
        Periph function;
    };

    // Pin name helpers
    const Pin PA00 = {Port::A,  0};
    const Pin PA01 = {Port::A,  1};
    const Pin PA02 = {Port::A,  2};
    const Pin PA03 = {Port::A,  3};
    const Pin PA04 = {Port::A,  4};
    const Pin PA05 = {Port::A,  5};
    const Pin PA06 = {Port::A,  6};
    const Pin PA07 = {Port::A,  7};
    const Pin PA08 = {Port::A,  8};
    const Pin PA09 = {Port::A,  9};
    const Pin PA10 = {Port::A, 10};
    const Pin PA11 = {Port::A, 11};
    const Pin PA12 = {Port::A, 12};
    const Pin PA13 = {Port::A, 13};
    const Pin PA14 = {Port::A, 14};
    const Pin PA15 = {Port::A, 15};
    const Pin PA16 = {Port::A, 16};
    const Pin PA17 = {Port::A, 17};
    const Pin PA18 = {Port::A, 18};
    const Pin PA19 = {Port::A, 19};
    const Pin PA20 = {Port::A, 20};
    const Pin PA21 = {Port::A, 21};
    const Pin PA22 = {Port::A, 22};
    const Pin PA23 = {Port::A, 23};
    const Pin PA24 = {Port::A, 24};
    const Pin PA25 = {Port::A, 25};
    const Pin PA26 = {Port::A, 26};
    const Pin PA27 = {Port::A, 27};
    const Pin PA28 = {Port::A, 28};
    const Pin PA29 = {Port::A, 29};
    const Pin PA30 = {Port::A, 30};
    const Pin PA31 = {Port::A, 31};
    const Pin PB00 = {Port::B,  0};
    const Pin PB01 = {Port::B,  1};
    const Pin PB02 = {Port::B,  2};
    const Pin PB03 = {Port::B,  3};
    const Pin PB04 = {Port::B,  4};
    const Pin PB05 = {Port::B,  5};
    const Pin PB06 = {Port::B,  6};
    const Pin PB07 = {Port::B,  7};
    const Pin PB08 = {Port::B,  8};
    const Pin PB09 = {Port::B,  9};
    const Pin PB10 = {Port::B, 10};
    const Pin PB11 = {Port::B, 11};
    const Pin PB12 = {Port::B, 12};
    const Pin PB13 = {Port::B, 13};
    const Pin PB14 = {Port::B, 14};
    const Pin PB15 = {Port::B, 15};
    const Pin PC00 = {Port::C,  0};
    const Pin PC01 = {Port::C,  1};
    const Pin PC02 = {Port::C,  2};
    const Pin PC03 = {Port::C,  3};
    const Pin PC04 = {Port::C,  4};
    const Pin PC05 = {Port::C,  5};
    const Pin PC06 = {Port::C,  6};
    const Pin PC07 = {Port::C,  7};
    const Pin PC08 = {Port::C,  8};
    const Pin PC09 = {Port::C,  9};
    const Pin PC10 = {Port::C, 10};
    const Pin PC11 = {Port::C, 11};
    const Pin PC12 = {Port::C, 12};
    const Pin PC13 = {Port::C, 13};
    const Pin PC14 = {Port::C, 14};
    const Pin PC15 = {Port::C, 15};
    const Pin PC16 = {Port::C, 16};
    const Pin PC17 = {Port::C, 17};
    const Pin PC18 = {Port::C, 18};
    const Pin PC19 = {Port::C, 19};
    const Pin PC20 = {Port::C, 20};
    const Pin PC21 = {Port::C, 21};
    const Pin PC22 = {Port::C, 22};
    const Pin PC23 = {Port::C, 23};
    const Pin PC24 = {Port::C, 24};
    const Pin PC25 = {Port::C, 25};
    const Pin PC26 = {Port::C, 26};
    const Pin PC27 = {Port::C, 27};
    const Pin PC28 = {Port::C, 28};
    const Pin PC29 = {Port::C, 29};
    const Pin PC30 = {Port::C, 30};
    const Pin PC31 = {Port::C, 31};

    // The PinState type can be used for clearer types, even though it's basically a boolean
    using PinState = bool;
    const PinState HIGH = true;
    const PinState LOW = false;

    // Interrupts handling
    const uint8_t N_GPIO_LINES = 96; // Max on the 100-pin package
    const uint8_t N_INTERRUPT_CHANNELS = N_GPIO_LINES / 8; // Each interrupt channel covers 8 GPIO lines
    extern uint32_t portsState[]; // Used for rising(), falling() and changed()
    extern uint32_t interruptHandlers[];

    // Error codes
    const Error::Code ERR_PIN_ALREADY_IN_USE = 1;
    const Error::Code ERR_HANDLER_NOT_DEFINED = 2;


    // Module API

    // Basic GPIO functions
    void enableInput(const Pin& pin, Pulling pulling=Pulling::NONE);
    void enableOutput(const Pin& pin, PinState value);
    void setPulling(const Pin& pin, Pulling pulling);
    PinState get(const Pin& pin);
    void set(const Pin& pin, PinState value);

    // Pin peripheral functions
    // This is usually called by other library modules, not by the user
    void enablePeripheral(const Pin& pin);
    void disablePeripheral(const Pin& pin);

    // Interrupts
    void enableInterrupt(const Pin& pin, void (*handler)(), Trigger trigger=Trigger::RISING);
    void enableInterrupt(const Pin& pin, Trigger trigger=Trigger::RISING);
    void disableInterrupt(const Pin& pin);

    // Helper functions
    inline bool isHigh(const Pin& pin) { return get(pin) == HIGH; };
    inline bool isLow(const Pin& pin) { return get(pin) == LOW; };
    inline void setHigh(const Pin& pin) { set(pin, HIGH); };
    inline void setLow(const Pin& pin) { set(pin, LOW); };
    void blip(const Pin& pin);

    // These functions monitor the pins state by polling and are a simple
    // way to check for a signal change, e.g. checking for a button press
    bool risingEdge(const Pin& pin);
    bool fallingEdge(const Pin& pin);
    bool changed(const Pin& pin);

    // PA00 and PB00 can be turned on and off quickly with these functions.
    // This is useful for debug purposes, when you want to switch a pin when something
    // has happened but you want to use as few clock cycles as possible
    inline void enablePA00() {enableOutput({GPIO::Port::A, 0}, GPIO::LOW);}
    inline void setHighPA00() {((volatile RSCT_REG*)(GPIO_BASE + OFFSET_OVR))->SET = 1;}
    inline void setLowPA00() {((volatile RSCT_REG*)(GPIO_BASE + OFFSET_OVR))->CLEAR = 1;}
    inline void enablePB00() {enableOutput({GPIO::Port::B, 0}, GPIO::LOW);}
    inline void setHighPB00() {((volatile RSCT_REG*)(GPIO_BASE + PORT_REG_SIZE + OFFSET_OVR))->SET = 1;}
    inline void setLowPB00() {((volatile RSCT_REG*)(GPIO_BASE + PORT_REG_SIZE + OFFSET_OVR))->CLEAR = 1;}

    // Internal initialization function. This is called in Core::init() and don't have to
    // be called by the user.
    void init();

}


#endif